#include <opencv2/opencv.hpp>

using namespace cv;
using namespace std;

//4.4.3 행렬을 영상 파일로 저장(16/32비트로 영상 저장) 

//실행결과 
//img8 행렬의 일부
//[33, 14, 23, 34, 15, 24, 32, 13, 22;
//35, 16, 25, 35, 16, 25, 32, 13, 22;
//34, 15, 24, 32, 13, 22, 30, 11, 20]
//
//img16 행렬의 일부
//[8481, 3598, 5911, 8738, 3855, 6168, 8224, 3341, 5654;
//8995, 4112, 6425, 8995, 4112, 6425, 8224, 3341, 5654;
//8738, 3855, 6168, 8224, 3341, 5654, 7710, 2827, 5140]
//
//img32 행렬의 일부
//[0.12941177, 0.054901965, 0.090196081, 0.13333334, 0.058823533, 0.094117656, 0.1254902, 0.050980397, 0.086274512;
//0.13725491, 0.062745102, 0.098039225, 0.13725491, 0.062745102, 0.098039225, 0.1254902, 0.050980397, 0.086274512;
//0.13333334, 0.058823533, 0.094117656, 0.1254902, 0.050980397, 0.086274512, 0.11764707, 0.043137256, 0.078431375]
//
//같은 이미지라도 저장되는 타입에 따라 행렬원소의 값이 다 다르다. 

int main() {

	Mat img8 = imread("C:/Users/Raynor/Desktop/openCVEXImage/image1.jpg", IMREAD_COLOR);
	//컬러영상으로 변환하여 반환

	CV_Assert(img8.data);									//영상파일 예외 처리 
	Mat img16, img32;										//다른 타입으로 처리할 변수 선언
	
	img8.convertTo(img16, CV_16U, 65535 / 255.0);			//형변환 및 원소 스케일 조정, 행렬 자료형 변환시 원소 비율 지정 
	img8.convertTo(img32, CV_32F, 1 / 255.0f);

	Rect roi(10, 10, 3, 3);												//화소 값 확인을 위한 관심영역 
	cout << " img8 행렬의 일부 " << endl << img8(roi) << endl << endl;	//roi크기 만큼 관심영역을 정해 이미지의 일부를 출력한다.
	cout << " img16 행렬의 일부 " << endl << img16(roi) << endl << endl;
	cout << " img32 행렬의 일부 " << endl << img32(roi) << endl << endl;
	
	imwrite("C:/Users/Raynor/Desktop/openCVEXImage/write_test_16.tif",img16); //행렬 영상파일로 저장
	imwrite("C:/Users/Raynor/Desktop/openCVEXImage/write_test_32.tif", img32);	

	imshow("img16",img16);
	imshow("img32", img32);
	waitKey();
	return 0;
}

