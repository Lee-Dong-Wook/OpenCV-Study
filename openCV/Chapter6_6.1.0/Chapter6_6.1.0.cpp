#include <opencv2/opencv.hpp>
using namespace std;
using namespace cv;

//6.1.0 잘못된 행렬 원소에 접근 

//화소는 pixel : 화면(영상)을 구성하는 가장 기본이 되는 단위
//디지털 영상은 이 화소들의 집합

//영상처리는 2차원 데이터에 대한 행렬 연산
//영상 처리프로그래밍은 영상이라는 2차원 데이터의 원소값을 원하는 방향으로 변경하는 ㄱ것 
//영상을 다루려면 영상의 화소에 접근, 그 값을 수정 혹은 새로 생성 

//Mat::at() 은 행렬의 지정된 원소(화소)에 접근하는 템플릿 함수 
//각 인수는 0~2차원 인덱스 
//다채널 행렬 경우 vec객체를 통해서도 가능 

//* Point 객체로 접근할 경우, x좌표가 먼저, Point(x,y) 형식이 되어야한다. 즉 col, row 순이다* 
//* 또한 레퍼런스라 대입연산자를 사용할 때 좌변에서도 사용가능하다. *
//** at()함수를 사용할 때 자료형은 행렬원소의 자료형과 동일, 반환자료형은 행렬원소의 조회간격으로 사용되기 때문 **

//m1, m2행렬을 같이 int(CV_32S)형으로 선언
//그리고 Mat::at()함수의 반환자료형을 다르게 지정하여 같은 값(k)을 지정 


//실행결과 
//debug 모드로 실행하면 결과를 볼수 없다. 
//int로 읽을 때는 문제가 없지만 short로 읽으면 이상이 생긴다. 
//CV_32S형은 int형을 나타며 CV_16U, CV_16S이 각각 unsigned, signed short int 형이다. 
//[m1] = [0,  1,  2,  3,  4;
//		  5,  6,  7,  8,  9;
//		  10, 11, 12, 13, 14]
//
//[m2] = [65536,  196610, 1309933572, 588,        1309950544;
//		  393221, 524295, 9,          1309951408, 588;
//		  720906, 851980, 1309933582, 588,        1309952176]
//
//[m3] = [0,  1,  2,  3,  4;
//		  5,  6,  7,  8,  9;
//		  10, 11, 12, 13, 14]

int main() {

	Mat m1(3, 5, CV_32S);
	Mat m2(3, 5, CV_32S);
	Mat m3(3, 5, CV_16S);

	for (int i = 0, k = 0; i < m1.rows; i++) {
		for (int j = 0; j < m1.cols; j++, k++) {

			m1.at<int>(i, j) = k;
			m2.at<short>(i, j) = k;
			m3.at<short>(i, j) = k;
			
		}
	}

	cout << " [m1] = " << m1 << endl;
	cout << " [m2] = " << m2 << endl;
	cout << " [m3] = " << m3 << endl;
	return 0;
}