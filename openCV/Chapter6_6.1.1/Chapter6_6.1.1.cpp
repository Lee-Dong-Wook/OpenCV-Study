#include <opencv2/opencv.hpp>
using namespace std;
using namespace cv;

//6.1.1 Mat::at()을 통한 행렬 원소 접근 

//실행결과 
//[m1] =
//[0, 1, 2, 3, 4;
// 5, 6, 7, 8, 9;
// 10, 11, 12, 13, 14]

//[m2] =
//[0, 1, 2, 3, 4;
// 0, 1, 2, 3, 4;
// 0, 1, 2, 3, 4]

//[m3] =
//[0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
// 0, 1, 0, 1, 0, 1, 0, 1, 0, 1;
// 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]

//[m4] =
//[0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2;
// 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2;
// 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]


int main() {

	Mat m1(3, 5, CV_32SC1);			//1채널 int형 
	Mat m2(3, 5, CV_32FC1);			//1채널 float형
	Mat m3(3, 5, CV_8UC2);			//2채널 uchar형 
	Mat m4(3, 5, CV_32SC3);			//3채널 int형 
	
	for (int i = 0, k = 0; i < m1.rows; i++) {			//행렬 원소 순회 
		for (int j = 0; j < m1.cols; j++, k++) {

			m1.at<int>(i, j) = k;						//i행, j열에 접근, 반환자료형 int
			Point pt(j,i);								//Point객체 j열, i행, pt로 행렬 원소 접근  
			m2.at<float>(pt) = (float)j;                //0,0 = 0  1,0 = 1  2,0 = 2  3,0  = 3  4,0 = 4
														//0,1 = 0  1,1 = 1  2,1 = 2  3,1  = 3  4,1 = 4
														//0,2 = 0  1,2 = 1  2,2 = 2  3,2  = 3  4,2 = 4


			int idx[2] = { i, j };

			m3.at<Vec2b>(idx) = Vec2b(0, 1);			//2채널 행렬이기에 반환자료형 Vec2b	
														//하나의 화소에 2개의 원소가 들어간다 

			m4.at<Vec3i>(i, j)[0] = 0;					//3채널 행렬로 반환자료형 Vec3i
			m4.at<Vec3i>(i, j)[1] = 1;					//하나의 화소는 크기3의 벡터, 즉 하나의 화소에 0,1,2 원소가 들어간다	
			m4.at<Vec3i>(i, j)[2] = 2;
		}
	}

	cout << "[m1] = " << endl << m1 << endl;
	cout << "[m2] = " << endl << m2 << endl;
	cout << "[m3] = " << endl << m3 << endl;
	cout << "[m4] = " << endl << m4 << endl;

	return 0;
}